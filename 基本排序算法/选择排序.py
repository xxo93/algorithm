# -*- coding: utf-8 -*-
""" 选择排序算法
# 描述
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。
所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

# 算法思路
1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

# 算法过程:
举个栗子（第一趟的排序过程）
原始序列：49、38、65、97、76、13、27、49
1）在进行选择排序过程中分成有序和无序两个部分，开始都是无序序列
结果：49、38、65、97、76、13、27、49
2）从无序序列中取出最小的元素13，将13同无序序列第一个元素交换，此时产生仅含一个元素的有序序列，无序序列减一
结果：{13、}   {38、65、97、76、49、27、49}
3）从无序序列中取出最小的元素27，将27同无序序列第一个元素交换，此时产生仅两个元素的有序序列，无序序列减一
结果：{13、27、}   {65、97、76、49、38、49}
4）从无序序列中取出最小的元素38，将38同无序序列第一个元素交换，此时产生含三个元素的有序序列，无序序列减一
结果：{13、27、38、}   {97、76、49、65、49}
5）从无序序列中取出最小的元素49，将49同无序序列第一个元素交换，此时产生含四个个元素的有序序列，无序序列减一
结果：{13、27、38、49、}   {76、97、65、49}
6）从无序序列中取出最小的元素49，将49同无序序列第一个元素交换，此时产生含五个元素的有序序列，无序序列减一
结果：{13、27、38、49、49、}   {97、65、76}
7）从无序序列中取出最小的元素65，将65同无序序列第一个元素交换，此时产生含六个元素的有序序列，无序序列减一
结果：{13、27、38、49、49、65}   {97、76}
8）从无序序列中取出最小的元素76，将76同无序序列第一个元素交换，此时产生含七个元素的有序序列，无序序列减一
结果：{13、27、38、49、49、65、76、}   {97}
9）最后一个元素肯定是最大元素，无序排序直接生产一个有序的序列
结果：{13、27、38、49、49、65、76、97}
"""


def selectionSort(arr):
    """ 选择排序 """
    for i in range(len(arr)):
        # 记录最小值的索引，初始为第0个元素开始
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[min_idx] > arr[j]:
                # 记录最小值的索引
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr



if __name__ == '__main__':
    arr = [3, 6, 5, 1, 8, 2, 9, 6, 7]
    print(selectionSort(arr))
